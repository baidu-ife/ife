#JavaScript作用域学习笔记#

----------

* 作用域
* 作用域链
* JavaScript的预编译

----------

##作用域分类##

JavaScript作用域的原理：**JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里**。

###1. 全局作用域###

在代码中任何地方都能访问到的对象拥有全局作用域。

* 最外层函数和在最外层函数外面定义的变量拥有全局作用域
* 所有未定义直接赋值的变量自动声明为拥有全局作用域（即没有使用var关键字定义变量）
* 所有window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等

###2. 局部作用域###

局部作用域一般只在固定的代码片段内可访问到，例如函数内部。

##作用域链##

在JavaScript中，函数也是对象。函数有一个内部属性为[[scope]]，包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。(即，[scope]属性包含了作用域链scope chain）

当一个**函数创建**时，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。并将作用域链链接到这个函数对象的[[scope]]属性。例如，在全局作用域中创建一个函数，则它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。

当一个**函数调用**时，会创建一个名为“运行期上下文（execution context）”的内部对象。运行期上下文定义了函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[scope]]所包含的对象。

函数的参数及内部函数会按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“**活动对象**（activation object）”。该对象包含了函数的所有局部变量、命名参数、参数集合以及this（对于每一个函数的形参，都命名为该活动对象的命名属性），然后此对象会被推入作用域链的前端，并将函数对象的[[scope]]加入到作用域链中。当运行期上下文被销毁，活动对象也随之销毁。

例如：

    var func = function(lps, rps) {
    	var name = 'laruence';
    	……
    }
    func();

在上述代码中，定义func函数时，会创建一个这个函数对象的[[scope]]属性，并将这个[[scope]]属性，链接到定义它的作用域链上。此时的[[scope]]指向全局活动对象window active object。

在调用func函数时：

* 会创建一个活动对象Obj，并创建arguments属性，然后会给这个对象添加两个命名属性Obj.lps，Obj.rps。对于每一个在这个函数中申明的局部变量和函数定义，都作为该活动对象的同名属性。
* 将调用参数赋值给形参，对于缺少的调用参数，赋值为undefined。
* 将该活动对象作为作用域链的最前端，并将func的[[scope]]属性所指向的，定义func时候的顶级活动对象加入到作用域链。

在发生标识符解析的时候，会逆向查询当前的scope chain列表的每一个活动对象的属性。找到同名的就返回，否则就是没有定义该属性。

##JavaScript预编译##

JavaScript在执行**每一段JS代码**之前，都会首先处理var关键字和function定义式（包括函数定义式和函数表达式）。

由于在调用函数执行之前，会首先创建一个活动对象，然后搜寻这个函数中的局部变量定义和函数定义，将变量名和函数名都作为这个活动对象的同名属性。

**对于局部变量定义**，变量的值会在真正执行的时候才计算，此时只是简单的赋为undefined。

**注意：**不使用var关键字定义的变量，相当于是全局变量。

例如：

    age = 26;

在对age做标识符解析时，由于是写操作，所以在预编译时找到全局的window活动对象的时候都没有找到这个标识符，因此会在window活动对象的基础上，返回一个值为undefined的age属性。

例如：

    var name = 'laruence';
	function echo() {
		alert(name);
		var name = 'eve';
		alert(name);
		alert(age);
	}
	echo();

运行结果为：

	undefined
	eve
	[脚本出错]

这是因为JavaScript在进行预编译时，检测到echo()函数中的局部变量name，因此赋值为undefined，在第一次alert的之后便输出了undefined。第二次alert是在执行运算过程中，name的值为'eve'。第三次alert由于没有定义age，所以输出'[脚本出错]'。

**对于函数的定义**，要注意函数定义式与函数表达式处理的不同之处。

* 函数定义式：
    
    	function eve() {
    		alert('I am Melanie');
    	};

函数定义式会将函数定义提前。

* 函数表达式：
    
    	var walle = function() {
    		alert('I am Melanie');
    	}

函数表达式会在执行过程中才计算。

例如：

    <script>
     	alert(typeof eve); 		//结果:function
     	alert(typeof walle); 	//结果:undefined
     	function eve() { 		//函数定义式
      		alert('I am Laruence');
     	};
     	var walle = function() { //函数表达式
     	}
     	alert(typeof walle); 	//结果:function
    </script>

